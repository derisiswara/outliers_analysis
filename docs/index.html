<!DOCTYPE html>
<html lang="en"><head>
<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/tabby.min.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.7.32">

  <title>Guidelines for outlier analysis</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/theme/quarto-f563837468303362081e247dddd440d0.css">
  <link rel="stylesheet" href="styles.css">
  <link href="index_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Guidelines for outlier analysis</h1>
  <p class="subtitle">Deri Siswara</p>

<div class="quarto-title-authors">
</div>

</section>
<section id="an-introduction-to-outlier-analysis" class="slide level2 smaller">
<h2>An introduction to outlier analysis</h2>
<ul>
<li><p>Outlier adalah sebuah pengamatan yang nilainya sangat berbeda jauh dari pengamatan lainnya, sehingga menimbulkan kecurigaan bahwa data tersebut mungkin berasal dari proses atau sumber yang berbeda.</p></li>
<li><p>Metode analisis outlier memiliki dua tipe output anslisis outlier, yaitu outlier scores (outlierness) dan label biner (outlier atau tidak).</p></li>
</ul>
<p><img data-src="img/1a.png" class="absolute" style="top: 250px; "></p>
</section>
<section id="an-introduction-to-outlier-analysis-1" class="slide level2 smaller">
<h2>An introduction to outlier analysis</h2>
<p>Outlier dapat berupa noise atau anomali. Tidak ada batasan yang jelas, semuanya bersifat <strong>subjektif</strong> tergantung pada analisis dan tujuan yang ingin dicapai.</p>
<p><img data-src="img/1b.png" class="absolute" style="top: 200px; "></p>
<aside class="notes">
<p>Noise: Fluktuasi / Variasi yang tidak terduga pada data. Anomali: “Sesuatu yang tidak biasa” pada data, perlu di tindaklanjuti.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="the-data-model-is-everything" class="slide level2 smaller">
<h2>The data model is everything</h2>
<p>Hampir semua algoritma deteksi outlier membangun model pola <strong>normal</strong> dalam data dan menghitung skor outlier berdasarkan deviasi dari pola tersebut. Oleh sebab itu, pemilihan model data sangat krusial. Sebagai contoh, metode deteksi outlier dengan Z-Score membutuhkan asumsi distribusi normal pada data.</p>
<p><img data-src="img/2a.png" class="absolute" style="top: 250px; "></p>
</section>
<section id="the-data-model-is-everything-1" class="slide level2 smaller">
<h2>The data model is everything</h2>
<p>Contoh lain: <strong>Model berbasis regresi</strong> akan paling cocok untuk menemukan pencilan dalam distribusi data pada Gambar berikut.</p>
<p><img data-src="img/2b.png" class="absolute" style="top: 200px; "></p>
</section>
<section id="probabilistic-and-statistical-models" class="slide level2 smaller">
<h2>Probabilistic and statistical models</h2>
<p>Metode analisis outlier berbasis model probabilistik dan statistik atau sebaran (distribusi data) populer sejak abad kesembilan belas. Misal metode Z-Score, IQR, dan Mahalanobis Distance. Kelemahan dari pendekatan ini adalah ketergantungan pada asumsi distribusi yang spesifik.</p>
<p><img data-src="img/iqr.png" class="absolute" style="top: 200px; left: 150px; width: 600px; height: 500px; "></p>
<aside class="notes">
<p>Z-Score, Modified Z-Score, IQR, Mahalanobis Distance, dll.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="linear-models" class="slide level2 smaller">
<h2>Linear models</h2>
<p>Atribut data di real world umumnya saling berkorelasi. Ketergantungan ini memungkinkan kita untuk saling memprediksi antar data. Outlier adalah nilai yang menyimpang dari nilai yang diharapkan (atau diprediksi) berdasarkan suatu model linear tertentu. Efektif saat korelasi tinggi dan dimensi rendah.</p>
<p><img data-src="img/lin1.png" class="absolute" style="top: 200px; left: 10px; width: 500px; height: 500px; "><br>
<img data-src="img/lin2.png" class="absolute" style="top: 200px; left: 500px; width: 500px; height: 500px; "></p>
<aside class="notes">
<p>The main assumption in linear models is that the (normal) data is embedded in a lower-dimensional subspace.</p>
<p>Cek: linear Modeling with Mean-Squared Projection Error Applications of Dependent Variable Modeling PCA Untuk dimensionality reduction. It can find optimal representation hyperplanes of any dimensionality. Bisa juga ke arah transformasi menjadi linier</p>
<p>Metode2: One Class SVM, Neural Networks.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="proximity-based-models" class="slide level2 smaller">
<h2>Proximity-based models</h2>
<p>Model berbasis kedekatan (proximity-based) mendefinisikan suatu titik data sebagai outlier apabila tingkat ketidakdekatan atau ketidakmiripan cukup jauh. Kedekatan sebuah titik data dapat didefinisikan dengan berbagai cara yang berbeda. Efektif ketika data mengandung sedikit noise.</p>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Berbasis Klaster (<strong>Cluster-based</strong>): Suatu titik data dianggap outlier jika tidak masuk ke dalam klaster manapun.</li>
<li>Berbasis Jarak (<strong>Distance-based</strong>): Suatu titik data dianggap outlier jika jaraknya ke titik-titik data terdekat (misalnya, k-tetangga terdekat) sangat besar.</li>
<li>Berbasis Kepadatan (<strong>Density-based</strong>): Suatu titik data dianggap outlier jika daerah sekitarnya (dalam radius atau wilayah tertentu) memiliki jumlah titik data yang sedikit.</li>
</ul>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:45%;">
<p><img data-src="img/prox1.png" class="absolute" style="top: 200px; width: 500px; height: 500px; "></p>
</div></div>
<aside class="notes">
<p>global and local analysis in proximity-based LOF: Local Outlier Factor termasuk density-based</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="outlier-ensembles" class="slide level2 smaller">
<h2>Outlier ensembles</h2>
<p>Metode ini menggabungkan hasil output dari beberapa algoritma atau metode menjadi satu hasil. Ide dasarnya adalah bahwa beberapa algoritma mungkin bekerja lebih baik pada bagian data tertentu, sementara algoritma lain lebih unggul pada bagian data yang berbeda.</p>
<p>Dalam membuat metode ensemble, ada dua pilihan penting:</p>
<ul>
<li><p><strong>Pemilihan Base Detector:</strong> Langkah awal adalah memilih base detector. Base detector ini berupa metode yang berbeda, parameter yang berbeda, atau bahkan data yang telah direkonstruksi dari data asli.</p></li>
<li><p><strong>Normalisasi dan Penggabungan Skor:</strong> Setiap detector mungkin menghasilkan skor dengan skala yang berbeda. Misalnya, detector k-nearest neighbor menghasilkan skor berupa jarak mentah, sedangkan algoritma LOF memberikan nilai yang sudah dinormalisasi. Karena perbedaan ini, penting untuk menormalkan skor dari berbagai detector sehingga dapat digabungkan. Setelah dinormalisasi, kita harus memilih cara untuk menggabungkan skor—umumnya dengan mengambil rata-rata atau nilai maksimum dari skor-skor tersebut.</p></li>
</ul>
<aside class="notes">
<p>Bias adalah kesalahan sistematis yang muncul karena model atau asumsi yang kita gunakan tidak sesuai dengan data sebenarnya. Misalnya, jika model kita mengasumsikan distribusi outlier yang berbeda dari kenyataan, maka hasilnya akan secara konsisten menyimpang dari nilai ideal.</p>
<p>Variance adalah variabilitas atau fluktuasi hasil model ketika kita menggunakan dataset pelatihan yang berbeda. Contohnya, jika skor outlier dari metode k-nearest neighbor berubah-ubah karena dataset pelatihan yang berbeda, maka itu merupakan variance.</p>
<p>Contoh Metode: Kebanyakan metode2 ensamble learning seperti Random Forest, Gradient Boosting, isolation forest, dll.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="the-basic-data-types-for-analysis" class="slide level2 smaller">
<h2>The basic data types for analysis</h2>
<p>Data bisa jauh lebih kompleks baik dalam hal jenis atribut maupun ketergantungan antar titik, seperti terlihat pada contoh data dunia nyata yang mencakup atribut kategorikal, teks, dan campuran.</p>
<h4 id="times-series-data-and-data-streams">Times-Series Data and Data Streams</h4>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li><p><strong>Time Series Data:</strong> Data yang diukur dan dicatat secara berurutan sepanjang waktu—biasanya pada interval yang konsisten—sehingga kita dapat melihat tren atau pola dari waktu ke waktu.</p></li>
<li><p><strong>Data Streaming:</strong> Data yang terus mengalir secara real-time. Data ini diproses seketika saat diterima dan tidak selalu tersimpan secara lengkap.</p></li>
</ul>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:45%;">
<p><img data-src="img/ts1.png" class="absolute" style="top: 200px; width: 500px; height: 400px; "></p>
</div></div>
</section>
<section id="time-series-and-streaming-outlier" class="slide level2 smaller">
<h2>Time series and streaming outlier</h2>
<h4 id="perubahan-mendadak-dalam-deret-waktu">Perubahan mendadak dalam deret waktu</h4>
<p>Suatu nilai dianggap outlier jika tidak konsisten dengan data sebelumnya, baik dalam jangka pendek (perubahan tiba-tiba) maupun jangka panjang (pola atau bentuk yang berbeda). Jika seluruh deret waktu tersedia secara offline, kita bisa memanfaatkan data historis untuk mendeteksi anomali. Jika ada beberapa data deret waktu, korelasi antar deret juga bisa dipertimbangkan, meskipun data time series sangat bergantung pada konteks waktu.</p>
<h4 id="deteksi-novelty-dan-perubahan">Deteksi novelty dan perubahan</h4>
<p>Outlier pada data deret waktu belum bisa dikatakan sebagai anomali. Outlier bisa jadi novelty atau pola baru yang belum terdeteksi sebelumnya. Bisa dalam bentuk:</p>
<ul>
<li><p>Perubahan tren agregat (kolektif). Pola subsekuens data berubah.</p></li>
<li><p>Perubahan pada titik individual (kontekstua). Titik data baru yang sangat berbeda dari data sebelumnya.</p></li>
</ul>
</section>
<section id="time-series-and-streaming-outlier-1" class="slide level2 smaller">
<h2>Time series and streaming outlier</h2>
<h4 id="prediction-based-outlier-detection-in-streaming-time-series">Prediction-based outlier detection in streaming time series</h4>
<p>Metode deteksi outlier pada data deret waktu streaming (real-time) dengan pendekatan prediksi, di mana titik data dianggap outlier (kontekstua) jika nilainya menyimpang secara signifikan dari nilai yang diprediksi oleh model (Misal regresi). Metode ini mengandalkan dua jenis korelasi:</p>
<ul>
<li><strong>Korelasi antar waktu:</strong> Nilai pada titik waktu berikutnya diprediksi berdasarkan nilai sebelumnya. Jika terjadi pelanggaran terhadap pola temporal yang kontinu, titik tersebut dianggap outlier.</li>
<li><strong>Korelasi antar individu:</strong> Misalnya, nilai dari satu bank dapat diprediksi dengan menggunakan data dari bank lain yang berkorelasi. Penyimpangan dari prediksi ini juga diindikasikan sebagai outlier.</li>
</ul>
<aside class="notes">
<p>The most common application of temporal outlier detection is that of detecting deviation- based outliers of specific time-instants with the use of regression-based forecasting models. These anomalies are contextual anomalies, because they define abnormalities at specific instants of the data, on the basis of relationships between data values at adjacent time instants.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="supervised-outlier-detection" class="slide level2 smaller">
<h2>Supervised Outlier Detection</h2>
<p>Dalam banyak kasus, beberapa data telah dilabeli sebagai <strong>ourlier atau anomali</strong> sehingga kita bisa melatih model pendeteksian outlier secara terawasi (supervised). Model ini menggunakan label untuk mengidentifikasi anomali sesuai dengan kebutuhan aplikasi, sehingga hasilnya bisa berbeda dengan metode yang tidak punya label (unsupervised). <em>The general recommendation for outlier analysis is to always use supervision where possible.</em></p>
<div style="text-align: center; margin-top: 1em">
<p>3, 2, 3, 2, 3, 87, 2, 2, 3, 3, 3, 84, 91, 86, 91, 81</p>
</div>
<div style="text-align: left; margin-top: 1em">
<p>Dalam konteks unsupervised,nilai <strong>87 dan 84</strong> bisa dianggap sebagai outlier. Dalam konteks transaksi kartu kredit, data historis yang sudah dilabeli menunjukkan bahwa pola nilai yang tinggi secara berurutan dapat dianggap sebagai anomali. Artinya, jika hanya terjadi satu nilai tinggi (<strong>misalnya 87</strong>) yang muncul secara terpisah, hal itu tidak dianggap anomali. Namun, jika nilai tinggi seperti 84 muncul dan diikuti oleh nilai-nilai tinggi lainnya, secara keseluruhan pola tersebut dianggap sebagai anomali karena menunjukkan perubahan tren yang tidak normal (Kolektif).</p>
</div>
<aside class="notes">
<p>Dalam konteks transaksi kartu kredit, data historis yang sudah dilabeli menunjukkan bahwa pola nilai yang tinggi secara berurutan dapat dianggap sebagai anomali. Artinya, jika hanya terjadi satu nilai tinggi (misalnya 87) yang muncul secara terpisah, hal itu tidak dianggap anomali. Namun, jika nilai tinggi seperti 84 muncul dan diikuti oleh nilai-nilai tinggi lainnya, secara keseluruhan pola tersebut dianggap sebagai anomali karena menunjukkan perubahan tren yang tidak normal.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="outlier-evaluation-techniques" class="slide level2 smaller">
<h2>Outlier evaluation techniques</h2>
<p>Evaluasi algoritma atau metode analisis outlier itu sulit karena outlier jarang terjadi dan data label (ground truth) sering tidak tersedia, terutama dalam skenario unsupervised. Banyak penelitian menggunakan validasi internal untuk evaluasi. Metode evaluasi internal (misalnya, mengukur “kebaikan” model dengan metrik seperti mean-squared radius) bisa dimanipulasi oleh algoritma tertentu sehingga tidak sepenuhnya andal. Dengan kata lain, interpretasinya bisa berbeda tergantung pada algoritma yang digunakan. Oleh karena itu, evaluasi eksternal lebih sering digunakan, yaitu dalam kerangka supervised. Evaluasi trade-off antara <strong>false positives</strong> dan <strong>false negatives</strong> diukur dengan metrik seperti precision dan recall.</p>
<p><img data-src="img/eval1.png" class="absolute" style="top: 400px; width: 600px; height: 300px; "></p>
<aside class="notes">
<p>Precision dihitung sebagai rasio antara jumlah pencilan yang terdeteksi dengan benar terhadap semua yang diprediksi sebagai pencilan. Recall dihitung sebagai rasio antara jumlah pencilan yang terdeteksi dengan benar terhadap total pencilan aktual. Lebih sensitif terhadap perubahan jumlah pencilan yang benar diidentifikasi, sehingga lebih cocok untuk evaluasi model deteksi pencilan</p>
<p>ROC curve memplot True Positive Rate (TPR) (sensitivitas) terhadap False Positive Rate (FPR) pada berbagai nilai ambang (threshold).</p>
<p>Dengan mengubah ambang deteksi, model akan menghasilkan kombinasi TPR dan FPR yang berbeda. ROC curve membantu melihat trade-off antara mendeteksi pencilan yang benar (TPR tinggi) dan menghindari kesalahan deteksi (FPR rendah). Tidak cocok untuk data tidak seimbang atau pencilan.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="outlier-evaluation-techniques-1" class="slide level2 smaller">
<h2>Outlier evaluation techniques</h2>
<h4 id="kesalahan-umum-dalam-evaluasi-outlier">Kesalahan umum dalam evaluasi outlier</h4>
<ul>
<li><p><strong>Pemilihan Paramter:</strong> Kesalahan umum dalam benchmarking algoritma analisis outlier terjadi ketika parameter yang ditetapkan oleh pengguna (misalnya, nilai k pada k-nearest neighbor) dioptimalkan dengan menggunakan label outlier. Hal ini bisa menyebabkan overfitting dan hasil yang bias.</p></li>
<li><p><strong>Risiko Overfitting:</strong> Model yang terlalu kompleks bisa menghasilkan hasil yang sangat baik pada data pelatihan, tetapi buruk pada data baru. Perlu dilakukan validasi eksternal dan evaluasi berkala untuk menghindari overfitting.</p></li>
<li><p><strong>Peran Pengalaman Analis:</strong> Karena dalam setting unsupervised tidak ada ground truth yang pasti, desain eksperimen dan pemilihan parameter sangat bergantung pada pengalaman dan penilaian yang baik dari analis (Expert Judgment.</p></li>
</ul>
</section>
<section id="guidelines-for-the-practitioner" class="slide level2 smaller">
<h2>Guidelines for the practitioner</h2>
<ul>
<li>Normalisasi data sangat penting.</li>
<li>Pembedaan antara noise dan anomali perlu diperhatikan.</li>
<li>Tahap ekstraksi fitur (prediktor) merupakan langkah yang krusial.</li>
<li>Domain knowledge seringkali mudah diintegrasikan ke dalam algoritma unsupervised.</li>
<li>Data berlabel (ground truth) sebaiknya digunakan jika memungkinkan.</li>
<li>Analisis eksploratif dan visual dapat berguna di seluruh tahap analisis outlier.</li>
<li>Keterlibatan manusia (human in the loop) mempermudah proses pelabelan dalam kombinasi dengan algoritma unsupervised.</li>
<li>Penggunaan metode ensemble outlier dapat mengurangi risiko overfitting.</li>
</ul>
</section>
<section id="which-unsupervised-algorithms-work-best" class="slide level2 smaller">
<h2>Which unsupervised algorithms work best?</h2>
<p>Sangat mustahil untuk mengidentifikasi algoritma optimal tanpa adanya ground truth. Karena masalah analisis outlier bersifat unsupervised, efektivitas suatu algoritma pada suatu dataset bergantung pada “keberuntungan” dalam mencerminkan distribusi sebenarnya dari data normal.</p>
</section>
<section id="illustrative-example" class="slide level2">
<h2>Illustrative example</h2>
<div style="text-align: center; margin-top: 2em">
<p><a href="https://rpubs.com/kayzedu/1272534" data-preview-link="true" style="text-align: center">Ilustarasi analisis outlier dengan R</a></p>
</div>
</section>
<section id="reference" class="slide level2 smaller">
<h2>Reference</h2>
<ul>
<li>Aggarwal, C. C., &amp; Aggarwal, C. C. (2017). Outlier analysis. Springer International Publishing.</li>
<li>https://rpubs.com/maulikpatel/228329</li>
<li></li>
</ul>

</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">
<p><span class="citation" data-cites="2025">@2025</span> - Deri Siswara</p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="index_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="index_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="index_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="index_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="index_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="index_files/libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="index_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="index_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="index_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="index_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="index_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': true,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"8\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":false},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
            const codeEl = trigger.previousElementSibling.cloneNode(true);
            for (const childEl of codeEl.children) {
              if (isCodeAnnotation(childEl)) {
                childEl.remove();
              }
            }
            return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>